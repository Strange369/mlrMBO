#' @title Initialize a manual sequential MBO run.
#' @description When you want to run a human-in-the-middle MBO run you need to initialize it first.
#'
#' @inheritParams mbo
#' @template arg_parset
#' @param minimize [\code{logical}]\cr
#'   Should target functions be minimized? One value par target function.
#'   Default is \code{TRUE} for ever target function.
#' @param noisy [\code{logical(1)}]\cr
#'   Is the target function noisy?
#'   Default is \code{FALSE}.
#'
#' @return [\code{\link{OptState}}]
#' @export
initSMBO = function(par.set, design, learner = NULL, control, minimize = TRUE, noisy = FALSE, show.info = getOption("mlrMBO.show.info", TRUE)) {

  assertClass(par.set, "ParamSet")
  assertDataFrame(design)
  assertSetEqual(names(design), c(getParamIds(par.set, repeated = TRUE, with.nr = TRUE) ,control$y.name))
  assertFlag(noisy)
  assertFlag(minimize)

  control$minimize = minimize
  control$noisy = noisy
  dummy.fun = makeSingleObjectiveFunction(name = "dummy", fn = function(...) return(NA), par.set = par.set, minimize = control$minimize, noisy = control$noisy)

  # assertions are done here:
  opt.problem = initOptProblem(fun = dummy.fun, design = design, learner = learner, control = control, show.info = show.info, more.args = list())
  opt.state = makeOptState(opt.problem)
  evalMBODesign.OptState(opt.state)
  finalizeMboLoop(opt.state)
  return(opt.state)
}

#' @title Updates SMBO with the new observations
#' @description After a function evaluation you want to update the \code{\link{opt.state}} to get new proposals.
#'
#' @param opt.state [\code{\link{OptState}}]
#'   The optimization state.
#'   Generated by \code{\link{initSMBO}}, this function or an \code{\link{mbo}} run.
#' @param x [\code{data.frame}]
#'   Named x values.
#' @param y [\code{numeric}]
#'   Outcome of the optimization.
#'
#' @return [\code{\link{OptState}}]
#' @export
updateSMBO = function(opt.state, x, y) {
  opt.problem = getOptStateOptProblem(opt.state)
  control = getOptProblemControl(opt.problem)
  infill.values = control$infill.crit$fun(points = x, models = getOptStateModels(opt.state)[[1]], control = control, attributes = TRUE)

  prop = list(
    prop.points = x,
    crit.components = attr(infill.values, "crit.components"),
    propose.time = NA_real_,
    prop.type = "manual",
    crit.vals = matrix(infill.values, ncol = 1L),
    errors.model = NA_character_)

  extras = getExtras(n = nrow(prop$prop.points), prop = prop, train.time = 0, control = control)
  xs = dfRowsToList(prop$prop.points, getOptProblemParSet(getOptStateOptProblem(opt.state)))

  for (i in seq_along(xs)) {
    addOptPathEl(op = getOptStateOptPath(opt.state), x = xs[[i]], y = y, extra = extras[[i]])
  }
  finalizeMboLoop(opt.state)
  invisible(opt.state)
}

#' @title Finalizes the SMBO Optimization
#' @description Returns the common mlrMBO result object.
#'
#' @param opt.state [\code{\link{OptState}}]
#'   The optimization state.
#'
#' @return [\code{\link{MBOSingleObjResult}} | \code{\link{MBOMultiObjResult}}]
#' @export
finalizeSMBO = function(opt.state) {
  mboFinalize2(opt.state)
}
